package EDLanguage.sandbox;

/*Generated by MPS */

import simcore.agents.Actor;
import simcore.basicStructures.Board;
import simcore.basicStructures.Location;
import simcore.basicStructures.ToolBox;
import simcore.diagnosis.CovidTest;
import simcore.diagnosis.InfectionState;
import simcore.diagnosis.InfectionStateType;
import simcore.diagnosis.InfectionStatus;
import simcore.diagnosis.TestResult;
import simcore.diagnosis.TrustRating;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import repast.simphony.context.Context;
import repast.simphony.space.SpatialMath;
import repast.simphony.space.continuous.ContinuousSpace;
import repast.simphony.space.continuous.NdPoint;
import repast.simphony.space.grid.Grid;
import repast.simphony.space.grid.GridPoint;
import repast.simphony.util.ContextUtils;
import simcore.Signals.Signal;
import simcore.action.basicAction.StayAction;

public class Staff extends Actor {
	private static int mintTotalStaffCount = 0;
	private Integer mintMyID;
	public double groupStress = Double.parseDouble("" + "0");
	public double trustForDiagnosisTool = 0;
	public List<TestResult> diagnosisToolHistory = new ArrayList<TestResult>();
	public List<TrustRating> trustRatingHistory = new ArrayList<TrustRating>();
	private InfectionState actualInfectionState;
	private InfectionState perceivedInfectionState; // What has the diagnosis tool told me about my infection state
	private Boolean stayHome = false;
	private int quarantineTimer;
	public Boolean isOnRota = false;
	private Location myHome;
	private Location currentLocation;

	public Staff(ContinuousSpace<Object> space, Grid<Object> grid) {
		super(space, grid);
		mintTotalStaffCount++;
		mintMyID = mintTotalStaffCount;
	}

	@Override
	public void Perceive() {
		// Take Test
		ToolBox toolBox = ToolBox();
		Double pdblCurrentTime = toolBox.getTime();

		System.out.println("--------------------------------------------------------------------------------------");
		System.out.println(this);
		System.out.println("Timestep: " + pdblCurrentTime);
		
		// if I am working today, then take my COVID test, revise my trust for it, and decide if I go to work or stay home
		if(isOnRota) {
			TestResult ptestResult = CovidTest.GetInstance().Test(this, pdblCurrentTime);
			System.out.println("My Actual HealthState: " + actualInfectionState);
			System.out.println("Test Result: " + ptestResult);

			// Revise trust for test
			reviseTrustForDiagnosisTool(ptestResult);

			// Decide 'do I trust result'
			Double pdblMyTrustForTool = getTrustForDiagnosisTool();
			System.out.println("My trust for test tool: " + pdblMyTrustForTool);

			// Log result in app

			// Update stay at home status
			if (stayHome) {
				System.out.println("I am staying at home!");
				MoveTo(myHome);
				quarantineTimer--;
				if (quarantineTimer == 0) {
					stayHome = false;
					quarantineTimer = 14; // <------------------------ Should be configurable
				}
			} else if (ptestResult.isInfected()) {
				if (pdblMyTrustForTool < 0) { // <----------------------- Should be configurable
					// go to work
					stayHome = false;
					System.out.println("I am going to work!");
					Location pLoc = ReadMap().FindPlace("Work");
					MoveTo(pLoc);
				} else {
					// stay at home
					System.out.println("I am staying at home!");
					MoveTo(myHome);
					stayHome = true;
					quarantineTimer = 14; // <------------------------ Should be configurable
				}
			} else {
				if (pdblMyTrustForTool < 0) { // <----------------------- Should be configurable
					// stay at home
					System.out.println("I am staying at home!");
					MoveTo(myHome);
					stayHome = true;
					quarantineTimer = 14; // <------------------------ Should be configurable
				} else {
					// go to work
					stayHome = false;
					System.out.println("I am going to work!");
					Location pLoc = ReadMap().FindPlace("Work");
					MoveTo(pLoc);
				}
			}
		} else {
			MoveTo(myHome);
			System.out.println("I am not on the rota today");
		}

		// Update Infection state (actual & perceived [TODO])
		actualInfectionState = actualInfectionState.step(this);

		System.out.println("--------------------------------------------------------------------------------------");
	}
	
	public void MoveTo(Location pLoc) {
		GridPoint pointOfTarget = grid.getLocation(pLoc);
		pointOfTarget = ((Location) pLoc).getEntryPoint();
		System.out.println("move to:" + pLoc);
		
		// if I am already here do nothing
		if (pLoc.WithInside(this)) {
			return;
		}
		// If not here move towards space
		else if (!SpaceAt(pointOfTarget)) {
			if(currentLocation != null) {
				currentLocation.LetOutPerson(this);
			}
			
			NdPoint myPoint = space.getLocation(this);
			NdPoint otherPoint = new NdPoint(pointOfTarget.getX(), pointOfTarget.getY());
			double angle = SpatialMath.calcAngleFor2DMovement(space, myPoint, otherPoint);
			space.moveTo(this, otherPoint.getX(), otherPoint.getY());
			myPoint = space.getLocation(this);
			grid.moveTo(this, (int) myPoint.getX(), (int) myPoint.getY());
			
			pLoc.TakePerson(this);
			currentLocation = pLoc;
		}
	}

	private void reviseTrustForDiagnosisTool(TestResult ptestResult) {
		ToolBox toolBox = ToolBox();
		Double pdblCurrentTime = toolBox.getTime();

		if (ptestResult.isInfected() == true) {
			if (actualInfectionState.stateType.getInfectionStatus() == InfectionStatus.Infected) {
				trustRatingHistory.add(new TrustRating(pdblCurrentTime, 0.33));
			} else {
				trustRatingHistory.add(new TrustRating(pdblCurrentTime, -0.33));
			}
		} else {
			if (actualInfectionState.stateType.getInfectionStatus() == InfectionStatus.Infected) {
				trustRatingHistory.add(new TrustRating(pdblCurrentTime, -0.33));
			} else {
				trustRatingHistory.add(new TrustRating(pdblCurrentTime, 0.33));
			}
		}
	}

	private double getTrustForDiagnosisTool() {
		double toolTrust = 0.0;
		ToolBox toolBox = ToolBox();
		Double pdblCurrentTime = toolBox.getTime();
		Map<TrustRating, Double> ratingWeightings = getRatingWeightings(trustRatingHistory);

		Iterator it = ratingWeightings.entrySet().iterator();
		while (it.hasNext()) {
			Map.Entry pair = (Map.Entry) it.next();
			toolTrust += (double) ((TrustRating) pair.getKey()).getRating() * ((double) pair.getValue());
		}

//		return toolTrust;
		return 1;
	}

	private Map<TrustRating, Double> getRatingWeightings(List<TrustRating> ratings) {
		Map<TrustRating, Double> ratingWeightings = new HashMap<>();
		Collections.sort(ratings, new TimeComparator());
		double weighting = 0.125; // <---------------------------------------- Should be configurable, changes
									// preference for rating recency
		for (int i = 0; i < ratings.size(); i++) {
			if (i < ratings.size() - 1) {
				weighting = weighting / 1.1; // <---------------------------------------- check this too
			}
			ratingWeightings.put(ratings.get(i), weighting);
		}

		return ratingWeightings;
	}

	public class TimeComparator implements Comparator<TrustRating> {
		@Override
		public int compare(TrustRating o1, TrustRating o2) {
			if (o1.getTimestamp() < o2.getTimestamp()) {
				return 1;
			} else if (o1.getTimestamp() > o2.getTimestamp()) {
				return -1;
			} else {
				return 0;
			}
		}
	}

	public void SetMission(Signal s) {
		switch (s.getName()) {
		case "":
			break;
		default:
			System.out.println("Set mission: " + s.getName() + " failed!");
			return;
		}
		curActionStep = 0;
	}

	public InfectionState getActualInfectionState() {
		return actualInfectionState;
	}

	public void setActualInfectionState(InfectionState pInfectionState) {
		actualInfectionState = pInfectionState;
	}
	
	@Override
	public String toString() {
		return "Staff " + mintMyID;
	}

	public Boolean amIStayingAtHome() {
		return stayHome;
	}
	
	public void setHome(Location plocMyHome) {
		myHome = plocMyHome;
	}

}
